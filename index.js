/**
 * URL Shortener Service (Node.js)
 *
 * This service handles link creation (POST /api/v1/shorten).
 * Key Generation: Switches from BIGSERIAL to a **decentralized UUID-based key**,
 * where the key is generated by Base62 encoding and truncating a UUID.
 * Persistence: Dual-writes to PostgreSQL (durable storage) and Redis (fast cache).
 */
const http = require("http");
const { Pool } = require("pg");
const Redis = require("ioredis");
// Include uuid library for generating keys if needed by the app
const { v4: uuidv4 } = require("uuid");

// --- 1. Database Configuration and Initialization ---

// PostgreSQL Pool for Durable Storage
const pgPool = new Pool({
    user: process.env.POSTGRES_USER || "postgres",
    host: "postgres",
    database: process.env.POSTGRES_DB || "urlshortener",
    password: process.env.POSTGRES_PASSWORD || "postgres",
    port: 5432,
    connectionTimeoutMillis: 5000,
    idleTimeoutMillis: 30000,
});

// Redis Client for High-Speed Cache/Lookup
const redisClient = new Redis({
    host: "redis",
    port: 6379,
});

redisClient.on("connect", () => {
    console.log("[REDIS] Successfully connected to Redis.");
});
redisClient.on("error", (err) => {
    console.error("[REDIS] Connection error:", err.message);
});

// --- 2. Key Generation & Encoding ---
const ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
const BASE = ALPHABET.length; // 62
const SHORT_URL_PREFIX = "http://s.ly/";
const KEY_LENGTH = 7; // Target short key length

/**
 * Encodes a byte array (like a UUID's 16 bytes) into a Base62 string.
 * This is a specialized function to compress the high entropy of a UUID.
 * @param {string} uuid - The raw UUID string (e.g., 'f5c37daa-e5f0-43d6-8f22-74a097eb4eab').
 * @returns {string} The Base62 encoded key, truncated to KEY_LENGTH.
 */
function uuidToShortKey(uuid) {
    // 1. Convert UUID to a BigInt (e.g., treating it as a single huge number)
    // Remove dashes and prepend '0x' to convert the hex string to a BigInt
    const hex = uuid.replace(/-/g, '');
    let num = BigInt('0x' + hex);

    // 2. Perform Base62 encoding on the resulting BigInt
    let encoded = "";
    while (num > 0n) {
        encoded = ALPHABET[Number(num % BigInt(BASE))] + encoded;
        num = num / BigInt(BASE);
    }
    
    // 3. Truncate the key to the desired length (KEY_LENGTH)
    // NOTE: Truncation risks collision, but the UNIQUE index handles it.
    return encoded.substring(0, KEY_LENGTH);
}

// --- 3. Persistence (Dual Write) Logic ---

/**
 * Saves the URL mapping, now relying on a UUID-derived key for auto-generation.
 * This is a ONE-STEP INSERT because the short_key is generated upfront.
 * @param {string|null} shortKey - The provided custom key, or null for auto-generation.
 * @param {string} longUrl - The original URL.
 * @param {Date} expiresAt - Expiration timestamp.
 * @returns {Promise<object>} The created record data.
 */
async function saveMapping(shortKey, longUrl, expiresAt) {
    const expiresAtISO = expiresAt.toISOString();

    if (!shortKey) {
        // Case 1: Auto-Generated Key from UUID
        let keyAttempts = 0;
        let success = false;
        
        while (!success && keyAttempts < 5) {
            const newUuid = uuidv4();
            shortKey = uuidToShortKey(newUuid);
            keyAttempts++;
            
            // Try to insert the new key
            try {
                const pgQuery = `
                    INSERT INTO url_mappings(short_key, long_url, expires_at)
                    VALUES($1, $2, $3)
                    RETURNING id; -- Returns the UUID primary key
                `;
                const result = await pgPool.query(pgQuery, [shortKey, longUrl, expiresAtISO]);
                const id = result.rows[0].id; // This is the UUID value
                success = true;
                console.log(`[UUID KEY] Generated Key: ${shortKey} from UUID: ${newUuid}. Attempts: ${keyAttempts}`);
                
                // 2. Write to Redis (High-Speed Read Path Cache)
                const expirationSeconds = Math.floor(
                    (expiresAt.getTime() - Date.now()) / 1000
                );
                await redisClient.set(shortKey, longUrl, "EX", expirationSeconds);
                console.log(`[REDIS DUAL WRITE] Cache set for key: ${shortKey}`);
            
                return {
                    id,
                    short_key: shortKey,
                    long_url: longUrl,
                    expires_at: expiresAtISO,
                };

            } catch (error) {
                // Check specifically for PG unique constraint violation (code '23505')
                if (error.code === '23505') { 
                    console.warn(`[UUID KEY] Collision detected for key '${shortKey}'. Retrying...`);
                    // Collision occurred, the loop will try the next generated key
                } else {
                    throw error; // Throw other errors immediately
                }
            }
        }
        
        if (!success) {
            throw new Error("Failed to generate a unique short key after multiple attempts due to high collision rate.");
        }


    } else {
        // Case 2: Custom Key (shortKey is provided by user)
        const pgQuery = `
            INSERT INTO url_mappings(short_key, long_url, expires_at)
            VALUES($1, $2, $3)
            RETURNING id;
        `;
        const result = await pgPool.query(pgQuery, [shortKey, longUrl, expiresAtISO]);
        const id = result.rows[0].id;
        
        // 2. Write to Redis (High-Speed Read Path Cache)
        const expirationSeconds = Math.floor(
            (expiresAt.getTime() - Date.now()) / 1000
        );
        await redisClient.set(shortKey, longUrl, "EX", expirationSeconds);
        console.log(`[REDIS DUAL WRITE] Cache set for key: ${shortKey}`);
        
        return {
            id,
            short_key: shortKey,
            long_url: longUrl,
            expires_at: expiresAtISO,
        };
    }
}


// --- 4. HTTP Server Implementation (URL Shortener Service) ---
function startServer() {
    const server = http.createServer(async (req, res) => {
        res.setHeader("Access-Control-Allow-Origin", "*");
        res.setHeader("Access-Control-Allow-Methods", "POST, GET, OPTIONS");
        res.setHeader("Access-Control-Allow-Headers", "Content-Type");

        if (req.method === "OPTIONS") {
            res.writeHead(204);
            res.end();
            return;
        }

        // Health Check 
        if (req.method === "GET" && req.url === "/") {
            res.writeHead(200, { "Content-Type": "text/plain" });
            res.end("URL Shortener Service is healthy and ready!");
            return;
        }

        if (req.method === "POST" && req.url === "/api/v1/shorten") {
            let body = "";

            req.on("data", (chunk) => {
                body += chunk.toString();
            });

            req.on("end", async () => {
                try {
                    if (!body) {
                        res.writeHead(400, { "Content-Type": "application/json" });
                        res.end(JSON.stringify({ error: "Request body cannot be empty." }));
                        return;
                    }

                    const { long_url: longUrl, custom_key: customKey } = JSON.parse(body);

                    if (!longUrl) {
                        res.writeHead(400, { "Content-Type": "application/json" });
                        res.end(
                            JSON.stringify({ error: "Missing long_url in request body." })
                        );
                        return;
                    }

                    const expiresAt = new Date(Date.now() + 365 * 24 * 60 * 60 * 1000);

                    let shortKey = customKey || null; // Use customKey or null for auto-generation check

                    if (customKey) {
                        // Check Redis for custom key existence (fast pre-check)
                        const exists = await redisClient.exists(customKey);
                        if (exists) {
                            res.writeHead(409, { "Content-Type": "application/json" });
                            res.end(
                                JSON.stringify({
                                    error: `Custom key '${customKey}' is already taken.`,
                                })
                            );
                            return;
                        }
                    }

                    // Persistence (Dual Write to PG and Redis, PG generates the ID)
                    const record = await saveMapping(shortKey, longUrl, expiresAt);

                    // Response to Client
                    res.writeHead(201, { "Content-Type": "application/json" });
                    res.end(
                        JSON.stringify({
                            id: record.id,
                            short_url: `${SHORT_URL_PREFIX}${record.short_key}`, 
                            long_url: longUrl,
                            key: record.short_key,
                            expires_at: record.expires_at,
                            message: customKey
                                ? "Custom link created."
                                : "Link created successfully.",
                        })
                    );
                } catch (error) {
                    console.error("Processing error:", error.stack);
                    // Check specifically for PG unique constraint violation (code '23505')
                    if (error.code === '23505') { 
                        res.writeHead(409, { "Content-Type": "application/json" });
                        res.end(
                            JSON.stringify({
                                error: "Key conflict: Custom key is already taken or generated key clashed (rare). Please retry the request.",
                            })
                        );
                    } else if (error.message.includes("Failed to generate")) {
                         res.writeHead(503, { "Content-Type": "application/json" });
                        res.end(
                            JSON.stringify({
                                error: error.message
                            })
                        );
                    } else {
                        res.writeHead(500, { "Content-Type": "application/json" });
                        res.end(
                            JSON.stringify({
                                error:
                                    "Internal server error during request processing. Check logs for database connection issues.",
                            })
                        );
                    }
                }
            });
        } else {
            res.writeHead(404, { "Content-Type": "text/plain" });
            res.end("Not Found. Use GET / or POST /api/v1/shorten");
        }
    });

    const PORT = 3000;
    server.listen(PORT, () => {
        console.log(`\nURL Shortener Service is now listening on port ${PORT}`);
    });
}

// --- 5. Initialization Chain (Retry and Server Start Logic) ---

// Helper function to wait for a delay
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

/**
 * Attempts to connect to PostgreSQL and set up the necessary schema with retries.
 */
async function connectWithRetry(retries = 10) {
    let client;
    try {
        console.log(`[PG INIT] Attempting connection to PostgreSQL... (Attempts left: ${retries})`);
        client = await pgPool.connect();
        
        // 1. Ensure UUID extension is installed
        await client.query(`CREATE EXTENSION IF NOT EXISTS "uuid-ossp";`);

        // 2. Create Table with UUID ID (The source of our key entropy)
        await client.query(`
            CREATE TABLE IF NOT EXISTS url_mappings (
                -- UUID is used for global uniqueness and to eliminate the BIGSERIAL bottleneck.
                id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), 
                -- short_key is now generated from a truncated, Base62-encoded UUID.
                short_key VARCHAR(10) UNIQUE NOT NULL, 
                long_url TEXT NOT NULL,
                created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
                expires_at TIMESTAMP WITH TIME ZONE
            );
        `);
        
        console.log("[PG] Verified/Created url_mappings table with UUID primary key. READY.");
        client.release();
        return true; // Success
    } catch (err) {
        if (client) {
            client.release(); // Ensure connection is released on error
        }

        if (err.code === 'ECONNREFUSED' && retries > 0) {
            const delay = 2000; // 2 seconds delay
            console.warn(`[PG INIT] Connection refused. Retrying in ${delay / 1000}s...`);
            await sleep(delay);
            return connectWithRetry(retries - 1); // Recurse with one fewer retry
        }

        console.error("[PG] FATAL: Initial database connection or setup failed. Shutting down:", err.stack);
        return false; // Fatal error
    }
}

// Start the whole initialization process
connectWithRetry()
    .then((success) => {
        if (success) {
            // Start the server only after DB init is confirmed
            startServer();
        } else {
            console.error("Unrecoverable database error. Exiting process.");
        }
    });
