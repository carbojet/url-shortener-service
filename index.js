/**
 * URL shortener Service (Node.js)
 * * Handles POST requests to shorten URLs, integrates Base62 encoding, and uses UUIDs.
 */
const http = require("http");
const { Pool } = require("pg");
const Redis = require("ioredis");
// We need a library to generate UUIDs
const { v4: uuidv4 } = require("uuid");

// Note: To use the 'uuid' package, you must ensure it's in your package.json:
// "dependencies": { "pg": "^8.x", "ioredis": "^5.x", "uuid": "^9.x" }

// --- 1. Database Configuration and Initialization ---

// PostgreSQL Pool for Durable Storage
const pgPool = new Pool({
  user: process.env.POSTGRES_USER || "postgres",
  host: "postgres",
  database: process.env.POSTGRES_DB || "urlshortener",
  password: process.env.POSTGRES_PASSWORD || "postgres",
  port: 5432,
  connectionTimeoutMillis: 5000,
  idleTimeoutMillis: 30000,
});

pgPool
  .connect()
  .then((client) => {
    console.log("[PG] Successfully connected to PostgreSQL.");

    // IMPORTANT: Enable UUID support and update the table schema to use UUID
    client
      .query(`CREATE EXTENSION IF NOT EXISTS "uuid-ossp";`)
      .then(() => {
        console.log("[PG] UUID extension ensured.");
        return client.query(`
                CREATE TABLE IF NOT EXISTS url_mappings (
                    -- Changed to UUID for global uniqueness
                    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), 
                    short_key VARCHAR(10) UNIQUE NOT NULL,
                    long_url TEXT NOT NULL,
                    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
                    expires_at TIMESTAMP WITH TIME ZONE
                );
            `);
      })
      .then(() => {
        console.log(
          "[PG] Verified/Created url_mappings table with UUID primary key."
        );
      })
      .catch((err) => {
        console.error("[PG] Error creating table or extension:", err.stack);
      })
      .finally(() => {
        client.release();
      });
  })
  .catch((err) => {
    console.error("[PG] Initial database connection failed:", err.stack);
  });

// Redis Client for High-Speed Cache/Lookup
const redisClient = new Redis({
  host: "redis",
  port: 6379,
});

redisClient.on("connect", () => {
  console.log("[REDIS] Successfully connected to Redis.");
});
redisClient.on("error", (err) => {
  console.error("[REDIS] Connection error:", err.message);
});

// --- 2. Key Generation & Encoding ---
const ALPHABET =
  "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
const BASE = ALPHABET.length; // 62
const SHORT_URL_PREFIX = "http://s.ly/";

// NOTE: We now use the KGS mock only for generating the number used to create the short_key.
// The actual primary key 'id' will be a UUID, generated either by Postgres or the app.

let currentEncodingId = 10000000;

/**
 * Returns a sequential number used only for Base62 encoding.
 * @returns {number} A number for encoding.
 */
function getEncodingId() {
  currentEncodingId += Math.floor(Math.random() * 5) + 1;
  return currentEncodingId;
}

/**
 * Encodes a decimal number into a Base62 string (short_key).
 */
function encode(num) {
  if (num === 0) return ALPHABET[0];
  let encoded = "";
  while (num > 0) {
    encoded = ALPHABET[num % BASE] + encoded;
    num = Math.floor(num / BASE);
  }
  return encoded;
}

// --- 3. Persistence (Dual Write) Logic ---

/**
 * Saves the URL mapping permanently to PostgreSQL and quickly to Redis.
 */
async function saveMapping(shortKey, longUrl, expiresAt) {
  const expiresAtISO = expiresAt.toISOString();
  // We let Postgres generate the UUID for the 'id' field automatically.

  // 1. Write to PostgreSQL (Durable Storage)
  const pgQuery = `
        INSERT INTO url_mappings(short_key, long_url, expires_at)
        VALUES($1, $2, $3)
        RETURNING id; -- Return the UUID generated by Postgres
    `;
  const result = await pgPool.query(pgQuery, [shortKey, longUrl, expiresAtISO]);
  const id = result.rows[0].id;
  console.log(
    `[PG DUAL WRITE] Durable record created with UUID: ${id} for key: ${shortKey}`
  );

  // 2. Write to Redis (High-Speed Read Path Cache)
  const expirationSeconds = Math.floor(
    (expiresAt.getTime() - Date.now()) / 1000
  );
  await redisClient.set(shortKey, longUrl, "EX", expirationSeconds);
  console.log(
    `[REDIS DUAL WRITE] Cache set for key: ${shortKey} with TTL: ${expirationSeconds}s`
  );

  return {
    id,
    short_key: shortKey,
    long_url: longUrl,
    expires_at: expiresAtISO,
  };
}

// --- 4. HTTP Server Implementation (URL shortener Service) ---
const server = http.createServer(async (req, res) => {
  res.setHeader("Access-Control-Allow-Origin", "*");
  res.setHeader("Access-Control-Allow-Methods", "POST, GET, OPTIONS");
  res.setHeader("Access-Control-Allow-Headers", "Content-Type");

  if (req.method === "OPTIONS") {
    res.writeHead(204);
    res.end();
    return;
  }

  // Health Check (omitted for brevity, assume current logic is sufficient)
  if (req.method === "GET" && req.url === "/") {
    res.writeHead(200, { "Content-Type": "text/plain" });
    res.end("URL shortener Service is healthy and ready!");
    return;
  }

  if (req.method === "POST" && req.url === "/api/v1/shorten") {
    let body = "";

    req.on("data", (chunk) => {
      body += chunk.toString();
    });

    req.on("end", async () => {
      try {
        if (!body) {
          res.writeHead(400, { "Content-Type": "application/json" });
          res.end(JSON.stringify({ error: "Request body cannot be empty." }));
          return;
        }

        const { long_url: longUrl, custom_key: customKey } = JSON.parse(body);

        if (!longUrl) {
          res.writeHead(400, { "Content-Type": "application/json" });
          res.end(
            JSON.stringify({ error: "Missing long_url in request body." })
          );
          return;
        }

        const expiresAt = new Date(Date.now() + 365 * 24 * 60 * 60 * 1000);

        let shortKey;

        if (customKey) {
          // Check Redis for custom key existence
          const exists = await redisClient.exists(customKey);
          if (exists) {
            res.writeHead(409, { "Content-Type": "application/json" });
            res.end(
              JSON.stringify({
                error: `Custom key '${customKey}' is already taken.`,
              })
            );
            return;
          }
          shortKey = customKey;
        } else {
          // Generate new key from sequential number
          const encodingId = getEncodingId();
          console.log(`[KGS MOCK] Acquired encoding ID: ${encodingId}`);
          shortKey = encode(encodingId);
          console.log(`[BASE62] Encoded ID ${encodingId} to Key: ${shortKey}`);
        }

        // Persistence (Dual Write to PG and Redis, PG generates the UUID)
        const record = await saveMapping(shortKey, longUrl, expiresAt);

        // Response to Client
        res.writeHead(201, { "Content-Type": "application/json" });
        res.end(
          JSON.stringify({
            id: record.id, // Now returns the new UUID
            short_url: `${SHORT_URL_PREFIX}${shortKey}`,
            long_url: longUrl,
            key: shortKey,
            expires_at: record.expires_at,
            message: customKey
              ? "Custom link created."
              : "Link created successfully.",
          })
        );
      } catch (error) {
        console.error("Processing error:", error.stack);
        res.writeHead(500, { "Content-Type": "application/json" });
        res.end(
          JSON.stringify({
            error:
              "Internal server error during request processing. Check logs for database connection issues.",
          })
        );
      }
    });
  } else {
    res.writeHead(404, { "Content-Type": "text/plain" });
    res.end("Not Found. Use GET / or POST /api/v1/shorten");
  }
});

const PORT = 3000;
server.listen(PORT, () => {
  console.log(`\nURL shortener Service is running internally on port ${PORT}`);
});
